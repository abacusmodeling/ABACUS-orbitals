"""advanced"""
def determine_type(parsed: dict):
    """pseudopotentials can be generated by not only one codes, to extract information 
    from PP_INFO, PP_INPUTFILE, need to know the exact way how information is organized
    """

    """ONCVPSP
    ONCVPSP is the format of pseudopotential most seen in norm-conserving pseudopotential,
    such as SG15, PD (developed by pwmat team?) and DOJO"""
    if "ONCVPSP" in parsed["PP_INFO"]["data"]:
        return "ONCVPSP"
    if "ONCVPSP" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ONCVPSP"

    """ADC
    ADC is the format of pseudopotential collected in pslibrary, including
    pslnc, rrkjus and kjpaw, most collected in QE website the pptable"""
    if "ADC" in parsed["PP_INFO"]["data"]:
        return "ADC"
    if "ADC" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ADC"
    if "ADC" in parsed["PP_HEADER"]["attrib"]["author"]:
        return "ADC"
    if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_INFO"]["data"]:
        return "ADC"
    if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ADC"
    if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_HEADER"]["attrib"]["author"]:
        return "ADC"
    
    """GTH
    this is the kind developed by CP2K developers, Goedecker, Hartwigsen, Hutter and Teter
    et al. However, this kind of pseudopotential has non-diagonal element in DIJ matrices,
    which is not supported by ABACUS yet."""
    if "Goedecker/Hartwigsen/Hutter/Teter" in parsed["PP_HEADER"]["attrib"]["author"]:
        return "GTH"
        raise NotImplementedError("GTH pseudopotential is not supported by ABACUS yet because of non-diagonal DIJ matrices")
    
    """GBRV
    It is one of the most efficient pseudopotential presently, ABACUS pw supports this kind
    of pseudopotential, ABACUS lcao not yet.
    """
    if "Generated using Vanderbilt code" in parsed["PP_INFO"]["data"]:
        return "GBRV"

    """ATOMPAW
    atompaw looks like ADC but not quite the same in occupation information
    Comparatively the uni_marburg is actually more similar to ADC"""
    if "ATOMPAW" in parsed["PP_INFO"]["data"]:
        return "ATOMPAW"
    if "ATOMPAW" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ATOMPAW"
    
    raise ValueError("Pseudopotential type not recognized")

def val_conf(parsed: dict):
    """extract valence electron configuration from pseudopotential file
    return element symbol followed by a list of lists, 
    [
        ["1s", "2s"] # for s
        ["2p"] # for p
        ["3d"] # for d
        ["4f"] # for f
    ]"""
    pseudo_type = determine_type(parsed)
    if pseudo_type == "ONCVPSP":
        return ONCV_parser(parsed)
    elif pseudo_type == "ADC":
        return ADC_parser(parsed)
    elif pseudo_type == "GBRV":
        return GBRV_parser(parsed)
    elif pseudo_type == "ATOMPAW":
        return ATOMPAW_parser(parsed)
    elif pseudo_type == "GTH":
        raise ValueError("GTH pseudopotential does not have valence electron configuration information")
    else:
        raise ValueError("Pseudopotential type not recognized")

def z_val(parsed: dict):
    return float(parsed["PP_HEADER"]["attrib"]["z_val"])

def element(parsed: dict):

    return parsed["PP_HEADER"]["attrib"]["element"]

def ONCV_parser(parsed: dict) -> list:

    result = {}

    zval = parsed["PP_HEADER"]["attrib"]["z_val"]
    
    content = parsed["PP_INPUTFILE"]["data"]
    lines = [line.strip() for line in content.split("\n")]

    reference_config = []
    read_valence_config = False
    for line in lines:
        if line.startswith("#   n    l    f        energy (Ha)"):
            read_valence_config = True
            continue

        if read_valence_config:
            if line.startswith("#"):
                break
            else:
                if len(line.split()) >= 3:
                    reference_config.append(line)
    # reversely read the reference_config
    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]
    reference_config.reverse()
    for line in reference_config:
        if zval <= 0:
            break
        else:
            words = line.split()
            index = int(words[1])
            symbol = sequence[index]
            if symbol not in result:
                result[symbol] = []
            result[symbol].append(words[0]+symbol)
            zval -= float(words[2])
    # then convert to list
    result_list = []
    for isym, symbol in enumerate(sequence):
        if symbol in result:
            result_list.append(result[symbol])
        else:
            if isym >= len(result):
                break
            else:
                result_list.append([])
    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def GBRV_parser(parsed: dict) -> list:

    contents = parsed["PP_HEADER"]["data"]
    lines = [line.strip() for line in contents.split("\n")]

    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]

    result = {}
    read_valence_config = False
    for line in lines:
        if line.startswith("Wavefunctions"):
            read_valence_config = True
            continue
        if read_valence_config:
            if not line[0].isdigit():
                break
            else:
                words = line.split()
                symbol = words[0][-1]
                if symbol not in result:
                    result[symbol] = []
                result[symbol].append(words[0])
    
    # then convert to list
    result_list = []
    for isym, symbol in enumerate(sequence):
        if symbol in result:
            result_list.append(result[symbol])
        else:
            if isym >= len(result):
                break
            else:
                result_list.append([])
    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def ATOMPAW_parser(parsed: dict) -> list:

    result = {}

    contents = parsed["PP_INFO"]["data"]
    lines = [line.strip() for line in contents.split("\n")]
    
    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]

    nmax = []
    norb = []
    iorb = 0
    read_valence_config = False
    for il, line in enumerate(lines):
        if il == 3: # this is the line specifying how many orbitals considered for s, p, d, f and g
            nmax = [int(x) for x in line.split()]
            norb = [(nmax[i] - i) if nmax[i] > i else 0 for i in range(len(nmax))]
            continue
        if line == "0 0 0":
            read_valence_config = True
            continue
        if read_valence_config:
            if not line[0].isalpha():
                break
            else:
                if line == "c": # core electron
                    pass
                elif line == "v": # valence electron
                    present_l = 0
                    present_n = 1
                    while iorb >= sum(norb[:present_l]):
                        present_l += 1
                    present_n += iorb - sum(norb[:present_l - 1]) + present_l - 1
                    symbol = sequence[present_l - 1]
                    if symbol not in result:
                        result[symbol] = []
                    result[symbol].append(str(present_n)+symbol)
                else:
                    raise ValueError("Unknown line in valelec_config: {}".format(line))
                iorb += 1
    # then convert to list
    result_list = []
    for isym, symbol in enumerate(sequence):
        if symbol in result:
            result_list.append(result[symbol])
        else:
            if isym >= len(result):
                break
            else:
                result_list.append([])
    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def ADC_parser(parsed: dict) -> list:

    result = {}

    content = parsed["PP_INFO"]["data"]
    lines = content.split("\n")

    read_valence_config = False
    for line in lines:
        line = line.strip()
        if line.startswith("Valence configuration:"):
            read_valence_config = True
            continue

        if line.startswith("Generation configuration:"):
            read_valence_config = False
            break

        if read_valence_config and line[0].isdigit():
            words = line.split()
            occ = float(words[3])
            if occ < 1e-6:
                print("""PSEUDOPOTENTIAL PARSE - towards_siab
Warning: present sublayer has occupation number less than 1e-6, this sublayer belongs to valence 
electron configuration but has actually no electron populated. Present strategy is to ignore this
sublayer, be sure if this is physical and expected.
If not happy with this, please change the code in SIAB/io/pseudopotential/tools/advanced.py""")
                print("Sublayer defined as valence with 0-occ.:", words[0], "-> skipped")
                continue
            result.setdefault(words[0][-1], []).append(words[0])
            
    # then convert to list
    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]
    result_list = []

    for isym, symbol in enumerate(sequence):
        if symbol in result:
            result_list.append(result[symbol])
        else:
            # it is not so intuitive: there may be the case like s, p and f
            # but no d, then the result_list should be like [[s], [p], [], [f]]
            if isym >= len(result):
                break
            else:
                result_list.append([])

    return parsed["PP_HEADER"]["attrib"]["element"], result_list
