"""advanced"""
def determine_type(parsed: dict):
    """pseudopotentials can be generated by not only one codes, to extract information 
    from PP_INFO, PP_INPUTFILE, need to know the exact way how information is organized
    """
    error_msg = """
##################################################################################################
! ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR
##################################################################################################

Pseudopotential with not recognized type, this is due to only limited support
implemented on orbital auto-generation feature. You can submit issue on Github Repository at:
https://github.com/kirk0830/abacus_orbital_generation. For instantly use, you can follow the
following guidelines. Please check manually the pseudopotential file you provided and specify:
1. ALL `nbands` with specific number
2. ALL `nbands_ref` with specific number
3. ALL `lmaxmax` with specific number
4. ALL `orb_conf` and `orb_ref` with specific configuration like either `[0, 1, 2, 3]` or `0s1p2d3f`
5. If you are using `optimizer` = `bfgs`, with `spill_guess` as `atomic`, a monomer (single atom) 
calculation will be run to generate the initial guess for orbital optimization. You should explicitly 
create one section in `reference_systems` for monomer calculation (setting `shape` to be `monomer`), 
and specify the `nbands` rationally (can be very high, but may also be dangerous because PW 
calculation cannot calculate isolated atom electronic structure well, artifact brought about by PW 
will pollute the energy level information).

Make sure in your input the following tags are correctly set:
{
    "element": [the element symbol],

    "reference_systems": [
        {
            "shape": "monomer",
            "nbands": NUMBER,
            "nspin": NUMBER,
            "lmaxmax": NUMBER
        },
        {
            "shape": "dimer",
            "nbands": NUMBER,
            "nspin": NUMBER,
            "lmaxmax": NUMBER,
            "bond_lengths": (can be "auto")
        },
        ...
    ],
    "orbitals": [
        {
            "zeta_notation": [S#]s[P#]p[D#]d[F#]f,
            "nbands": NUMBER,
            "orb_ref": "none" or [S#']s[P#']p[D#']d[F#']f,
            "shape": (the same),
        },
        ...
    ]
}
Then rerun the orbital generation.
TypeError raised, Quit..."""

    try:
        """ONCVPSP
        ONCVPSP is the format of pseudopotential most seen in norm-conserving pseudopotential,
        such as SG15, PD (developed by pwmat team?) and DOJO"""
        if "ONCVPSP" in parsed["PP_INFO"]["data"]:
            return "ONCVPSP"
        if "ONCVPSP" in parsed["PP_HEADER"]["attrib"]["generated"]:
            return "ONCVPSP"

        """ADC
        ADC is the format of pseudopotential collected in pslibrary, including
        pslnc, rrkjus and kjpaw, most collected in QE website the pptable"""
        if "ADC" in parsed["PP_INFO"]["data"]:
            return "ADC"
        if "ADC" in parsed["PP_HEADER"]["attrib"]["generated"]:
            return "ADC"
        if "ADC" in parsed["PP_HEADER"]["attrib"]["author"]:
            return "ADC"
        if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_INFO"]["data"]:
            return "ADC"
        if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_HEADER"]["attrib"]["generated"]:
            return "ADC"
        if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_HEADER"]["attrib"]["author"]:
            return "ADC"
        
        """GTH
        this is the kind developed by CP2K developers, Goedecker, Hartwigsen, Hutter and Teter
        et al. However, this kind of pseudopotential has non-diagonal element in DIJ matrices,
        which is not supported by ABACUS yet."""
        if "Goedecker/Hartwigsen/Hutter/Teter" in parsed["PP_HEADER"]["attrib"]["author"]:
            return "GTH"
            raise NotImplementedError("GTH pseudopotential is not supported by ABACUS yet because of non-diagonal DIJ matrices")
        
        """GBRV
        It is one of the most efficient pseudopotential presently, ABACUS pw supports this kind
        of pseudopotential, ABACUS lcao not yet.
        """
        if "Generated using Vanderbilt code" in parsed["PP_INFO"]["data"]:
            return "GBRV"

        """ATOMPAW
        atompaw looks like ADC but not quite the same in occupation information
        Comparatively the uni_marburg is actually more similar to ADC"""
        if "ATOMPAW" in parsed["PP_INFO"]["data"]:
            return "ATOMPAW"
        if "ATOMPAW" in parsed["PP_HEADER"]["attrib"]["generated"]:
            return "ATOMPAW"
        
        """vwr
        vwr is a old-fashioned pseudopotential format, there are codes can convert the vwr to upf format. Then this branch
        will be called to parse the upf format pseudopotential"""
        if "vwr" in parsed["PP_INFO"]["data"] or "VWR" in parsed["PP_INFO"]["data"]:
            return "VWR"
        
    except KeyError:
        print(error_msg, flush = True)
        raise TypeError("ERROR: please see error message above.")

def val_conf(parsed: dict):
    """extract valence electron configuration from pseudopotential file
    return element symbol followed by a list of lists, 
    [
        ["1s", "2s"] # for s
        ["2p"] # for p
        ["3d"] # for d
        ["4f"] # for f
    ]"""
    pseudo_type = determine_type(parsed)
    caller_map = {"ONCVPSP": ONCVPSPCodeParser, "ADC": AtomicADCCodeParser, "GBRV": GBRVParser, 
                  "ATOMPAW": ATOMPAWCodeParser, "VWR": AtomicADCCodeParser, "GTH": CP2KATOMCodeParser}
    return caller_map[pseudo_type](parsed)

def z_val(parsed: dict):
    """return the valence electron number from parsed pseudopotential."""
    return float(parsed["PP_HEADER"]["attrib"]["z_valence"])

def element(parsed: dict):
    """return the element symbol from parsed pseudopotential."""
    return parsed["PP_HEADER"]["attrib"]["element"]

def ONCVPSPCodeParser(parsed: dict) -> list:
    """ONCVPSP-code generated pseudopotential file specific-parser (unluckily have
    to implement this kind of parser one-by-one...)
    ONCVPSP-code can be download from:
    https://www.quantum-espresso.org/pseudopotentials/oncvpsp

    Args:
        parsed (dict): the parsed dictionary from pseudopotential file.
    
    Returns:
        list: a list of list of valence electron configuration.
    """
    out = {}

    zval = parsed["PP_HEADER"]["attrib"]["z_valence"]
    
    content = parsed["PP_INPUTFILE"]["data"]
    lines = [line.strip() for line in content.split("\n")]

    reference_config = []
    read_valence_config = False
    for line in lines:
        if line.startswith("#   n    l    f        energy (Ha)"):
            read_valence_config = True
            continue

        if read_valence_config:
            if line.startswith("#"):
                break
            else:
                if len(line.split()) >= 3:
                    reference_config.append(line)
    # reversely read the reference_config
    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]
    reference_config.reverse()
    for line in reference_config:
        if zval <= 0:
            break
        else:
            words = line.split()
            index = int(words[1])
            symbol = sequence[index]
            if symbol not in out:
                out[symbol] = []
            out[symbol].append(words[0]+symbol)
            zval -= float(words[2])
    # then convert to list
    result_list = []
    for isym, symbol in enumerate(sequence):
        if symbol in out:
            result_list.append(out[symbol])
        else:
            if isym >= len(out):
                break
            else:
                result_list.append([])
    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def GBRVParser(parsed: dict) -> list:
    """GBRV-code generated pseudopotential file specific-parser"""
    contents = parsed["PP_HEADER"]["data"]
    lines = [line.strip() for line in contents.split("\n")]

    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]

    out = {}
    read_valence_config = False
    for line in lines:
        if line.startswith("Wavefunctions"):
            read_valence_config = True
            continue
        if read_valence_config:
            if not line[0].isdigit():
                break
            else:
                words = line.split()
                symbol = words[0][-1]
                if symbol not in out:
                    out[symbol] = []
                out[symbol].append(words[0])
    
    # then convert to list
    result_list = []
    for isym, symbol in enumerate(sequence):
        if symbol in out:
            result_list.append(out[symbol])
        else:
            if isym >= len(out):
                break
            else:
                result_list.append([])
    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def ATOMPAWCodeParser(parsed: dict) -> list:

    result = {}

    contents = parsed["PP_INFO"]["data"]
    lines = [line.strip() for line in contents.split("\n")]
    
    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]

    nmax = []
    norb = []
    iorb = 0
    read_valence_config = False
    for il, line in enumerate(lines):
        if il == 3: # this is the line specifying how many orbitals considered for s, p, d, f and g
            nmax = [int(x) for x in line.split()]
            norb = [(nmax[i] - i) if nmax[i] > i else 0 for i in range(len(nmax))]
            continue
        if line == "0 0 0":
            read_valence_config = True
            continue
        if read_valence_config:
            if not line[0].isalpha():
                break
            else:
                if line == "c": # core electron
                    pass
                elif line == "v": # valence electron
                    present_l = 0
                    present_n = 1
                    while iorb >= sum(norb[:present_l]):
                        present_l += 1
                    present_n += iorb - sum(norb[:present_l - 1]) + present_l - 1
                    symbol = sequence[present_l - 1]
                    if symbol not in result:
                        result[symbol] = []
                    result[symbol].append(str(present_n)+symbol)
                else:
                    raise ValueError("Unknown line in valelec_config: {}".format(line))
                iorb += 1
    # then convert to list
    result_list = []
    for isym, symbol in enumerate(sequence):
        if symbol in result:
            result_list.append(result[symbol])
        else:
            if isym >= len(result):
                break
            else:
                result_list.append([])
    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def AtomicADCCodeParser(parsed: dict) -> list:

    result = {}

    content = parsed["PP_INFO"]["data"]
    lines = content.split("\n")

    read_valence_config = False
    for line in lines:
        line = line.strip()
        if line.startswith("Valence configuration:"):
            read_valence_config = True
            continue

        if line.startswith("Generation configuration:"):
            read_valence_config = False
            break

        if read_valence_config and line[0].isdigit():
            words = line.split()
            occ = float(words[3])
            if occ < 1e-6:
                print("""PSEUDOPOTENTIAL PARSE - towards_siab
Warning: present sublayer has occupation number less than 1e-6, this sublayer belongs to valence 
electron configuration but has actually no electron populated. Present strategy is to ignore this
sublayer, be sure if this is physical and expected.
If not happy with this, please change the code in SIAB/io/pseudopotential/tools/advanced.py""")
                print("Sublayer defined as valence with 0-occ.:", words[0], "-> skipped")
                continue
            result.setdefault(words[0][-1].upper(), []).append(words[0].upper())
            
    # then convert to list
    sequence = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]
    result_list = []

    for isym, symbol in enumerate(sequence):
        if symbol in result:
            result_list.append(result[symbol])
        else:
            # it is not so intuitive: there may be the case like s, p and f
            # but no d, then the result_list should be like [[s], [p], [], [f]]
            if isym >= len(result):
                break
            else:
                result_list.append([])

    return parsed["PP_HEADER"]["attrib"]["element"], result_list

def CP2KATOMCodeParser(parsed: dict) -> list:
    """GTH-code generated pseudopotential file specific-parser. Valence electron configuration
    is listed with the following format (always), if this pseudopotential is generated by CP2K
    ATOM code:
    
    Ce
    4    6    1    1
    0.53900468000000       2   18.85114190000000   -0.77960224000000
       4
    0.49808146000000       2    1.19529290000000    0.62204575000000
                                                   -1.62871685000000
    0.47069322000000       2    1.18088300000000    0.55487102000000
                                                   -1.53066452000000
    0.65606409000000       1    0.07990999000000
    0.30705426000000       1  -17.32458585000000

    The first line of this information block should be the element symbol, then the following
    is the number of electrons for each shell (s, p, d, f...).
    """
    error_msg = """ERROR: invalid format of GTH pseudopotential file. Check your pseudopotential
generation file (CP2K ATOM code input script), especially the &ATOM/&POTENTIAL/&GTH_POTENTIAL
section.
Raise TypeError, Quit..."""
    import re
    from numpy import ceil
    content = parsed['PP_INPUTFILE']['data']
    lines = content.split("\n")
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if re.match(r"[A-Z][a-z]?", line):
            element = line
            break
        i += 1
    if i == len(lines):
        print(error_msg, flush = True)
        raise TypeError("ERROR: see error message above.")
    val_ = lines[i+1].split()
    val_ = [int(x) for x in val_]
    spectrum = ["S", "P", "D", "F", "G", "H", "I", "K", "L", "M", "N"]
    out = []
    for i, nelec in enumerate(val_):
        degen = (2*i + 1)*2
        out.append([f"{j+1}{spectrum[i]}" for j in range(int(ceil(nelec/degen)))])

    return element, out